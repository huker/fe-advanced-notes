## eventLoop
> 事件环 微任务、宏任务
>
> 注意：在node环境下测试代码的时候要注意使用11版本 这样才能和浏览器最终的结果匹配

### 浏览器事件环

#### 线程、进程

- Js是单线程 同一时间内只能执行一件事情，这个单线程是指主线程，js还有一些方法是可以开辟新的线程，比如setTimeout，ajax，事件等
- 进程包含着线程 浏览器每个tab页都是一个进程 在进程里开启线程来跑我们的代码
- 主线程 js、ui公用同一个线程

#### 执行上下文

比如这个代码，首先在主栈里，最底下是全局上下文，然后a、b、c的执行上下文依次往主栈里叠，先进后出（a是第一个进去的但是最后一个被销毁，注意全局上下文是在浏览器关闭才销毁）

执行代码会在执行栈中执行（栈型结构)

>执行上下文和作用域不要搞混，作用域是定义时就已知了（所以说是js静态作用域）。执行上下文是执行这个函数的时候产生的，会放进执行栈里。比如在a函数中定义了x，b函数执行的时候就是通过执行上下文中的作用域链去寻找到x。

```javascript
//代码：1.start.js
function a() {
    let x = 1;
    function b() {
        console.log(x)
        function c() {
            console.log('>>')
        }
        c()
    }
    b()
}
a()
```

#### 任务执行顺序

在主栈执行的时候，可能会创建一些其他线程（定时器、ajax、事件等webapi产生的）

比如创建了定时器，然后就会开始计时，2s执行回调，时间到了后回调就会放在一个区别于主栈的队列里，等待主栈的代码执行完毕（主栈一直没空下来的话就不会去清别的任务），就会把队列中的第一个回调放到主栈中执行，清空主栈然后取队列下一个执行，这样循环往复。这个队列里叫做 **宏任务**

还可能会有promise.then的方法，这些会放在另一个队列里，主栈清空后会优先清空这个队列，然后再清上面宏任务队列。这个队列叫做 **微任务**。

> !!注意：虽然我们说先清微任务再清宏任务，但其实浏览器执行script脚本就一个是宏任务，所以最开始是把宏任务放进主栈执行，然后开始清空微任务，清空完微任务就去宏任务中取一个放进主栈继续执行，循环进行。

宏任务：ui渲染 script脚本 定时器 ajax 事件（click之类的）

微任务：Promise.then