###进一步完善redux 在react中使用
代码：redux/3.react-redux

####bindActionCreators产生

```jsx
<button onClick={store.dispatch({ type: INCREMENT })}>+</button>
```
这样写太繁琐，需要一步步简化：

1.定义actionCreator，顾名思义就是专门来定义action的

```javascript
// { type: INCREMENT } 变成
function increment(payload){
  return { type: INCREMENT, payload }
}
```

2.简化store.dispatch，实现自动绑定，出现bindActionCreators

```javascript
let actions = { increment, decrement };
actions = bindActionCreators(actions, store.dispatch);
```

bindActionCreators把actionCreators自动和dispatch绑定在一起，所以在我们的redux中也添加这个方法，bindActionCreators可以传入actionCreators，也可以直接传actionCreator，所以要添加判断

```javascript
// redux -> bindActionCreator.js
function bindActionCreator(actionCreator, dispatch) {
    // payload要带上
    return function (...args) {
        return dispatch(actionCreator(...args))
    }
}
export default function (actionCreators, dispatch) {
    if (typeof actionCreators === 'function') {
        return bindActionCreator(actionCreators, dispatch)
    }
    const boundActions = {};
    for ( let key in actionCreators ) {
        boundActions[key] = bindActionCreator(actionCreators[key], dispatch)
    }
    return boundActions
}
```

#### combinereducer产生

项目里会有很多组件，组件的状态如果都放在一个reducer里面写会很长，所以要拆开来写，这时候就需要一个方法来组合所有的reducer返回一个总的reducer函数，此时state也按照reducer结构变成了一个状态树

```javascript
// redux -> combineReducers.js
export default function combineReducers(reducers) {
    return function (state = {}, action) {
        let nextState = {};
        for ( let key in reducers ) {
            nextState[key] = reducers[key](state[key], action)
        }
        return nextState
    }
}
```

